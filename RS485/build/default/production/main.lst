CCS PCM C Compiler, Version 5.076, 56587               17-Mar-20 14:50

               Filename:   C:\Users\Planlama\Desktop\RS485\build\default\production\main.lst

               ROM used:   848 words (5%)
                           Largest free fragment is 2048
               RAM used:   56 (3%) at main() level
                           84 (4%) worst case
               Stack used: 0 locations
               Stack size: 16

*
0000:  MOVLP  00
0001:  GOTO   1AE
0002:  NOP
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  BTFSS  0B.5
0010:  GOTO   013
0011:  BTFSC  0B.2
0012:  GOTO   023
0013:  CLRF   05
0014:  MOVLW  91
0015:  MOVWF  04
0016:  BTFSS  00.5
0017:  GOTO   01A
0018:  BTFSC  11.5
0019:  GOTO   025
001A:  MOVF   20,W
001B:  MOVWF  77
001C:  MOVF   21,W
001D:  MOVWF  78
001E:  MOVF   22,W
001F:  MOVWF  79
0020:  MOVF   23,W
0021:  MOVWF  7A
0022:  RETFIE
0023:  MOVLP  00
0024:  GOTO   09F
0025:  MOVLP  00
0026:  GOTO   04A
.................... /*  
....................  * File:   main.c 
....................  * Author: Orkun OKUR 
....................  * 
....................  * Created on 12 Subat 2020 Çarsamba, 10:58 
....................  */ 
.................... #include 	<16F1788.h> 
.................... //////////// Standard Header file for the PIC16F1788 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1788 
*
00E8:  CLRF   78
00E9:  CLRF   79
00EA:  CLRF   77
00EB:  CLRF   7A
00EC:  MOVF   5D,W
00ED:  BTFSS  03.2
00EE:  GOTO   0F2
00EF:  MOVF   5C,W
00F0:  BTFSC  03.2
00F1:  GOTO   10C
00F2:  MOVLW  10
00F3:  MOVWF  5E
00F4:  BCF    03.0
00F5:  RLF    5A,F
00F6:  RLF    5B,F
00F7:  RLF    77,F
00F8:  RLF    7A,F
00F9:  MOVF   5D,W
00FA:  SUBWF  7A,W
00FB:  BTFSS  03.2
00FC:  GOTO   0FF
00FD:  MOVF   5C,W
00FE:  SUBWF  77,W
00FF:  BTFSS  03.0
0100:  GOTO   108
0101:  MOVF   5C,W
0102:  SUBWF  77,F
0103:  BTFSS  03.0
0104:  DECF   7A,F
0105:  MOVF   5D,W
0106:  SUBWF  7A,F
0107:  BSF    03.0
0108:  RLF    78,F
0109:  RLF    79,F
010A:  DECFSZ 5E,F
010B:  GOTO   0F4
010C:  RETURN
010D:  MOVLW  10
010E:  MOVWF  5E
010F:  CLRF   77
0110:  CLRF   7A
0111:  RRF    5B,F
0112:  RRF    5A,F
0113:  BTFSS  03.0
0114:  GOTO   11B
0115:  MOVF   5C,W
0116:  ADDWF  77,F
0117:  BTFSC  03.0
0118:  INCF   7A,F
0119:  MOVF   5D,W
011A:  ADDWF  7A,F
011B:  RRF    7A,F
011C:  RRF    77,F
011D:  RRF    79,F
011E:  RRF    78,F
011F:  DECFSZ 5E,F
0120:  GOTO   111
0121:  RETURN
*
0146:  BSF    0A.0
0147:  BCF    0A.1
0148:  BCF    0A.2
0149:  ADDWF  02,F
014A:  GOTO   128
014B:  GOTO   12B
014C:  GOTO   12E
014D:  GOTO   131
014E:  GOTO   134
014F:  GOTO   137
0150:  GOTO   13A
0151:  GOTO   13D
0152:  GOTO   140
0153:  GOTO   143
....................  
.................... #list 
....................  
.................... #device     PIC16F1788 
....................  
....................  
.................... #device 	adc=8 
.................... #FUSES      INTRC_IO, NOWDT, PUT, MCLR, PROTECT, CPD, BROWNOUT, NOCLKOUT, NOIESO, NOFCMEN, NOVCAP, BORV19  		 
.................... #use 		delay(clock=16000000) 
.................... //#use rs232  (baud=9600, xmit=PIN_C6, rcv=PIN_C7, ENABLE=PIN_A3, PARITY=E, STOP=1,FORCE_SW) 
.................... #use fast_io(c) 
.................... #use fast_io(a) 
.................... #ZERO_RAM 
....................  
.................... #include <stdio.h>	 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include	"Definition.h" 
.................... #define		timer1_value        61580 
.................... #define		timer0_value        132 
....................  
....................  
.................... //#define     LED         PIN_C6 
.................... #define     DIGIT1_COM  PIN_C1 
.................... #define     DIGIT2_COM  PIN_C0 
.................... #define     DIGIT3_COM  PIN_A5 
....................  
.................... #define RS485_ID    0x29  
.................... #define RS485_DEST_ID    0x17 
.................... #define RS485_RX_BUFFER_SIZE    8 
....................  
.................... #define RS485_RX_PIN       PIN_C7   // Data receive pin 
.................... #define RS485_TX_PIN       PIN_C6   // Data transmit pin 
.................... #define RS485_ENABLE_PIN   PIN_A3   // Controls DE pin.  RX low, TX high. 
....................  
....................  
....................  
....................  
....................  
.................... unsigned int8   TIME_MAKER,REG_10ms,REG_50ms,REG_100ms,REG_500ms,REG_1s,REG_10s; 
.................... unsigned int8   DigitOrder,DIGIT_1,DIGIT_2,DIGIT_3,DIGIT_TEMP; 
.................... unsigned int8   data; 
.................... unsigned int16  BCD_100,BCD_10,BCD_1; 
....................  
....................  
.................... #include	"DisplayDrive.h" 
....................  
....................  
.................... void DisplayDrive() 
.................... { 
.................... 	output_low(DIGIT1_COM); 
*
00A2:  MOVLB  02
00A3:  BCF    0E.1
.................... 	output_low(DIGIT2_COM); 
00A4:  BCF    0E.0
.................... 	output_low(DIGIT3_COM); 
00A5:  BCF    0C.5
....................  
....................  
....................     switch (DigitOrder) 
00A6:  MOVLB  00
00A7:  MOVF   2E,W
00A8:  BTFSC  03.2
00A9:  GOTO   0B1
00AA:  XORLW  01
00AB:  BTFSC  03.2
00AC:  GOTO   0BB
00AD:  XORLW  03
00AE:  BTFSC  03.2
00AF:  GOTO   0C5
00B0:  GOTO   0CE
....................     { 
....................         case 0: 
....................         OUTPUT_B(DIGIT_1); 
00B1:  MOVLB  01
00B2:  CLRF   0D
00B3:  MOVLB  00
00B4:  MOVF   2F,W
00B5:  MOVLB  02
00B6:  MOVWF  0D
....................         output_high(DIGIT1_COM); 
00B7:  BSF    0E.1
....................         ++DigitOrder; 
00B8:  MOVLB  00
00B9:  INCF   2E,F
....................         break; 
00BA:  GOTO   0CE
....................  
....................         case 1: 
....................         OUTPUT_B(DIGIT_2); 
00BB:  MOVLB  01
00BC:  CLRF   0D
00BD:  MOVLB  00
00BE:  MOVF   30,W
00BF:  MOVLB  02
00C0:  MOVWF  0D
....................         output_high(DIGIT2_COM); 
00C1:  BSF    0E.0
....................         ++DigitOrder; 
00C2:  MOVLB  00
00C3:  INCF   2E,F
....................         break; 
00C4:  GOTO   0CE
....................  
....................         case 2: 
....................         OUTPUT_B(DIGIT_3); 
00C5:  MOVLB  01
00C6:  CLRF   0D
00C7:  MOVLB  00
00C8:  MOVF   31,W
00C9:  MOVLB  02
00CA:  MOVWF  0D
....................         output_high(DIGIT3_COM); 
00CB:  BSF    0C.5
....................         DigitOrder=0; 
00CC:  MOVLB  00
00CD:  CLRF   2E
....................         break; 
....................  
....................      } 
.................... 	 
.................... }	 
....................  
.................... #include	"LookUpTable.h" 
.................... //       0b bfaeddpcg 
.................... void Convert7Segment(ref) 
.................... { 
.................... 	switch (ref) 
*
0122:  MOVF   55,W
0123:  ADDLW  F6
0124:  BTFSC  03.0
0125:  GOTO   145
0126:  ADDLW  0A
0127:  GOTO   146
.................... 	{ 
.................... 		case 0: 
.................... 		DIGIT_TEMP=(0b11111010); 
0128:  MOVLW  FA
0129:  MOVWF  32
.................... 		break; 
012A:  GOTO   145
....................  
.................... 		case 1: 
.................... 		DIGIT_TEMP=(0b10000010); 
012B:  MOVLW  82
012C:  MOVWF  32
.................... 		break; 
012D:  GOTO   145
....................  
.................... 		case 2: 
.................... 		DIGIT_TEMP=(0b10111001); 
012E:  MOVLW  B9
012F:  MOVWF  32
.................... 		break; 
0130:  GOTO   145
....................  
.................... 		case 3: 
.................... 		DIGIT_TEMP=(0b10101011); 
0131:  MOVLW  AB
0132:  MOVWF  32
.................... 		break; 
0133:  GOTO   145
....................  
.................... 		case 4: 
.................... 		DIGIT_TEMP=(0b11000011); 
0134:  MOVLW  C3
0135:  MOVWF  32
.................... 		break; 
0136:  GOTO   145
....................  
.................... 		case 5: 
.................... 		DIGIT_TEMP=(0b01101011); 
0137:  MOVLW  6B
0138:  MOVWF  32
.................... 		break; 
0139:  GOTO   145
....................  
.................... 		case 6: 
.................... 		DIGIT_TEMP=(0b01111011); 
013A:  MOVLW  7B
013B:  MOVWF  32
.................... 		break; 
013C:  GOTO   145
....................  
.................... 		case 7: 
.................... 		DIGIT_TEMP=(0b10100010); 
013D:  MOVLW  A2
013E:  MOVWF  32
.................... 		break; 
013F:  GOTO   145
....................  
.................... 		case 8: 
.................... 		DIGIT_TEMP=(0b11111011); 
0140:  MOVLW  FB
0141:  MOVWF  32
.................... 		break; 
0142:  GOTO   145
....................  
.................... 		case 9: 
.................... 		DIGIT_TEMP=(0b11101011); 
0143:  MOVLW  EB
0144:  MOVWF  32
.................... 		break; 
.................... 	} 
0145:  RETURN
....................  
....................  
.................... } 
....................  
.................... #include    <rs485.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                            RS485.c                              //// 
.................... ////                                                                 //// 
.................... ////      This file contains drivers for RS-485 communication        //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// int1 rs485_get_message(int* data_ptr, int wait)                 //// 
.................... ////     * Get a message from the RS485 bus                          //// 
.................... ////     * Address can be 1 - 33.                                    //// 
.................... ////     * A 1 will be returned if a parity check error occurred.    //// 
.................... ////                                                                 //// 
.................... //// int1 rs485_send_message(int to, int len, int* data)             //// 
.................... ////     * Send a message over the RS485 bus                         //// 
.................... ////     * Inputs:                                                   //// 
.................... ////          to    - Destination address                            //// 
.................... ////          len   - Message length                                 //// 
.................... ////          *data - Pointer to message                             //// 
.................... ////     * Returns TRUE if successful, FALSE if failed               //// 
.................... ////                                                                 //// 
.................... //// void rs485_wait_for_bus(int1 clrwdt)                            //// 
.................... ////     * Wait for the RS485 bus to open. Normally used before      //// 
.................... ////       sending a message to avoid collisions.                    //// 
.................... ////     * Pass in TRUE to restart the watch dog timer to prevent    //// 
.................... ////       the device from resetting.                                //// 
.................... ////     * This is not needed if sending an immediate response       //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef RS485_DRIVER 
.................... #define RS485_DRIVER 
....................  
.................... #ifndef RS485_ID 
.................... #define RS485_ID  0x10                 // The device's RS485 address or ID 
.................... #endif 
....................  
.................... #ifndef RS485_USE_EXT_INT 
.................... #define RS485_USE_EXT_INT FALSE        // Select between external interrupt 
.................... #endif                                 // or asynchronous serial interrupt 
....................  
....................  
.................... #if(RS485_USE_EXT_INT == FALSE) 
....................    #ifndef RS485_RX_PIN 
....................    #define RS485_RX_PIN       PIN_C7   // Data receive pin 
....................    #endif 
....................  
....................    #ifndef RS485_TX_PIN 
....................    #define RS485_TX_PIN       PIN_C6   // Data transmit pin 
....................    #endif 
....................  
....................    #ifndef RS485_ENABLE_PIN 
....................    #define RS485_ENABLE_PIN   PIN_B4   // Controls DE pin.  RX low, TX high. 
....................    #endif 
....................  
....................    #ifndef RS485_RX_ENABLE 
....................    #define RS485_RX_ENABLE    PIN_B5   // Controls RE pin.  Should keep low. 
....................    #endif 
....................  
....................    #use rs232(baud=9600, xmit=RS485_TX_PIN, rcv=RS485_RX_PIN, enable=RS485_ENABLE_PIN, bits=8, long_data, errors, stream=RS485) 
*
0027:  BTFSS  11.5
0028:  GOTO   027
0029:  MOVLB  03
002A:  MOVF   1D,W
002B:  MOVLB  00
002C:  MOVWF  3A
002D:  MOVLW  01
002E:  MOVLB  03
002F:  ANDWF  1D,W
0030:  MOVWF  79
0031:  MOVF   19,W
0032:  MOVWF  78
0033:  MOVLB  00
0034:  BTFSS  3A.1
0035:  GOTO   039
0036:  MOVLB  03
0037:  BCF    1D.4
0038:  BSF    1D.4
0039:  MOVLB  00
003A:  RETURN
....................    #use rs232(baud=9600, xmit=RS485_TX_PIN, rcv=RS485_RX_PIN, enable=RS485_ENABLE_PIN, bits=8, long_data, force_sw, multi_master, errors, stream=RS485_CD) 
....................  
....................    #if getenv("AUART") 
....................       #define RCV_OFF() {setup_uart(FALSE);} 
....................    #else 
....................       #define RCV_OFF() {setup_uart(FALSE);} 
....................    #endif 
.................... #else 
....................    #ifndef RS485_RX_PIN 
....................    #define RS485_RX_PIN       PIN_B0   // Data receive pin 
....................    #endif 
....................  
....................    #ifndef RS485_TX_PIN 
....................    #define RS485_TX_PIN       PIN_B3   // Data transmit pin 
....................    #endif 
....................  
....................    #ifndef RS485_ENABLE_PIN 
....................    #define RS485_ENABLE_PIN   PIN_B4   // Controls DE pin.  RX low, TX high. 
....................    #endif 
....................  
....................    #ifndef RS485_RX_ENABLE 
....................    #define RS485_RX_ENABLE    PIN_B5   // Controls RE pin.  Should keep low. 
....................    #endif 
....................  
....................    #use rs232(baud=9600, xmit=RS485_TX_PIN, rcv=RS485_RX_PIN, enable=RS485_ENABLE_PIN, bits=9, long_data, errors, stream=RS485) 
....................    #use rs232(baud=9600, xmit=RS485_TX_PIN, rcv=RS485_RX_PIN, enable=RS485_ENABLE_PIN, bits=9, long_data, multi_master, errors, stream=RS485_CD) 
....................  
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);} 
.................... #endif 
....................  
....................  
....................  
.................... #define RS485_wait_time 20             // Wait time in milliseconds 
....................  
.................... #bit    rs485_collision = rs232_errors.6 
....................  
.................... #ifndef RS485_RX_BUFFER_SIZE 
.................... #define RS485_RX_BUFFER_SIZE  8 
.................... #endif 
....................  
.................... unsigned int8 rs485_state, rs485_ni, rs485_no; 
.................... unsigned int8 rs485_buffer[RS485_RX_BUFFER_SIZE]; 
....................  
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
....................    #if (RS485_USE_EXT_INT==FALSE) 
....................       while(kbhit(RS485)) {getc();} // Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
*
00D1:  BTFSS  11.5
00D2:  GOTO   0D5
00D3:  CALL   027
....................       #if getenv("AUART") 
00D4:  GOTO   0D1
....................          setup_uart(UART_ADDRESS); 
00D5:  MOVLB  03
00D6:  BSF    1D.3
....................          setup_uart(TRUE); 
00D7:  BSF    1D.7
00D8:  BSF    1D.4
00D9:  BSF    1E.5
....................       #else 
....................          setup_uart(TRUE); 
....................       #endif 
....................    #else 
....................       clear_interrupt(INT_EXT); 
....................       enable_interrupts(INT_EXT); 
....................    #endif 
.................... } 
....................  
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void rs485_init() { 
....................    RCV_ON(); 
....................    rs485_state=0; 
00DA:  MOVLB  00
00DB:  CLRF   3B
....................    rs485_ni=0; 
00DC:  CLRF   3C
....................    rs485_no=0; 
00DD:  CLRF   3D
....................    #if RS485_USE_EXT_INT==FALSE 
....................    enable_interrupts(INT_RDA); 
00DE:  MOVLB  01
00DF:  BSF    11.5
....................    #else 
....................    ext_int_edge(H_TO_L); 
....................    enable_interrupts(INT_EXT); 
....................    #endif 
....................    enable_interrupts(GLOBAL); 
00E0:  MOVLW  C0
00E1:  IORWF  0B,F
....................    output_low(RS485_RX_ENABLE); 
00E2:  BCF    0D.5
00E3:  MOVLB  02
00E4:  BCF    0D.5
00E5:  MOVLP  00
00E6:  MOVLB  00
00E7:  GOTO   31C (RETURN)
.................... } 
....................  
....................  
.................... // The index for the temporary receive buffer 
.................... unsigned int8 temp_ni; 
....................  
.................... // Purpose:    Add a byte of data to the temporary receive buffer 
.................... // Inputs:     The byte of data 
.................... // Outputs:    None 
.................... void rs485_add_to_temp(unsigned int8 b) { 
....................    // Store the byte 
....................    rs485_buffer[temp_ni] = b; 
*
003B:  MOVLW  1E
003C:  ADDWF  46,W
003D:  MOVWF  04
003E:  MOVLW  20
003F:  MOVWF  05
0040:  BTFSC  03.0
0041:  INCF   05,F
0042:  MOVF   61,W
0043:  MOVWF  00
....................  
....................    // Make the index cyclic 
....................    if(++temp_ni >= RS485_RX_BUFFER_SIZE) 
0044:  INCF   46,F
0045:  MOVF   46,W
0046:  SUBLW  07
0047:  BTFSS  03.0
....................    { 
....................       temp_ni = 0; 
0048:  CLRF   46
....................    } 
0049:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:    Interrupt service routine for handling incoming RS485 data 
.................... #if (RS485_USE_EXT_INT==FALSE) 
.................... #int_rda 
.................... #else 
.................... #int_ext 
.................... #endif 
.................... void incomming_rs485() { 
....................    unsigned int16 b; 
....................    static unsigned int8  cs,state=0,len,info,data_address; 
....................    static unsigned int16 to,source; 
....................  
....................    b=fgetc(RS485); 
004A:  CALL   027
004B:  MOVF   79,W
004C:  MOVWF  60
004D:  MOVF   78,W
004E:  MOVWF  5F
....................    cs^=(unsigned int8)b; 
004F:  MOVF   5F,W
0050:  XORWF  47,F
....................  
....................    switch(state) { 
0051:  MOVF   48,W
0052:  BTFSC  03.2
0053:  GOTO   061
0054:  XORLW  01
0055:  BTFSC  03.2
0056:  GOTO   06D
0057:  XORLW  03
0058:  BTFSC  03.2
0059:  GOTO   078
005A:  XORLW  01
005B:  BTFSC  03.2
005C:  GOTO   07E
005D:  XORLW  FC
005E:  BTFSC  03.2
005F:  GOTO   086
0060:  GOTO   08D
....................       case 0:  // Get from address 
....................          temp_ni=rs485_ni; 
0061:  MOVF   3C,W
0062:  MOVWF  46
....................          source=b; 
0063:  MOVF   60,W
0064:  MOVWF  4F
0065:  MOVF   5F,W
0066:  MOVWF  4E
....................          cs=b; 
0067:  MOVF   5F,W
0068:  MOVWF  47
....................          rs485_add_to_temp(source); 
0069:  MOVF   4E,W
006A:  MOVWF  61
006B:  CALL   03B
....................          break; 
006C:  GOTO   091
....................  
....................       case 1:  // Get to address 
....................          to=b; 
006D:  MOVF   60,W
006E:  MOVWF  4D
006F:  MOVF   5F,W
0070:  MOVWF  4C
....................          rs485_add_to_temp(to); 
0071:  MOVF   4C,W
0072:  MOVWF  61
0073:  CALL   03B
....................          #if (getenv("AUART")&&(RS485_USE_EXT_INT==FALSE)) 
....................             setup_uart(UART_DATA); 
0074:  MOVLB  03
0075:  BCF    1D.3
....................          #endif 
....................          break; 
0076:  MOVLB  00
0077:  GOTO   091
....................           
....................        case 2: 
....................         data_address = b; 
0078:  MOVF   5F,W
0079:  MOVWF  4B
....................         rs485_add_to_temp(data_address); 
007A:  MOVF   4B,W
007B:  MOVWF  61
007C:  CALL   03B
....................        break; 
007D:  GOTO   091
....................  
....................        case 3:  // Get len 
....................          info=b; 
007E:  MOVF   5F,W
007F:  MOVWF  4A
....................          len=3; 
0080:  MOVLW  03
0081:  MOVWF  49
....................          rs485_add_to_temp(info); 
0082:  MOVF   4A,W
0083:  MOVWF  61
0084:  CALL   03B
....................          break; 
0085:  GOTO   091
....................  
....................       case 255:   // Get checksum 
....................          //if ((!cs)&&(bit_test(to,8))&&(bit_test(source,8))&&((unsigned int8)to==RS485_ID)) {  // If cs==0, then checksum is good 
....................             rs485_ni=temp_ni; 
0086:  MOVF   46,W
0087:  MOVWF  3C
....................          //} 
....................  
....................          #if (getenv("AUART")&&(RS485_USE_EXT_INT==FALSE)) 
....................             setup_uart(UART_ADDRESS); 
0088:  MOVLB  03
0089:  BSF    1D.3
....................          #endif 
....................  
....................          state=0; 
008A:  MOVLB  00
008B:  CLRF   48
....................          return; 
008C:  GOTO   09C
....................  
....................       default: // Get data 
....................          rs485_add_to_temp(b); 
008D:  MOVF   5F,W
008E:  MOVWF  61
008F:  CALL   03B
....................          --len; 
0090:  DECF   49,F
....................          break; 
....................    } 
....................    if ((state>=4) && (len==0)) { 
0091:  MOVF   48,W
0092:  SUBLW  03
0093:  BTFSC  03.0
0094:  GOTO   09B
0095:  MOVF   49,F
0096:  BTFSS  03.2
0097:  GOTO   09B
....................       state=255; 
0098:  MOVLW  FF
0099:  MOVWF  48
....................    } 
009A:  GOTO   09C
....................    else { 
....................       ++state; 
009B:  INCF   48,F
....................    } 
009C:  BCF    11.5
009D:  MOVLP  00
009E:  GOTO   01A
.................... } 
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... int1 rs485_send_message(unsigned int8 to, unsigned int8 len, unsigned int8* data) { 
....................    unsigned int8 try, i, cs; 
....................    int1 ret = FALSE; 
....................  
....................    RCV_OFF(); 
....................    #if RS485_USE_EXT_INT 
....................       disable_interrupts(GLOBAL); 
....................    #endif 
....................  
....................    for(try=0; try<5; ++try) { 
....................       rs485_collision = 0; 
....................       fputc((unsigned int16)0x100|rs485_id, RS485_CD); 
....................       fputc((unsigned int16)0x100|to, RS485_CD); 
....................       fputc(len, RS485_CD); 
....................  
....................       for(i=0, cs=rs485_id^to^len; i<len; ++i) { 
....................          cs ^= *data; 
....................          fputc(*data, RS485_CD); 
....................          ++data; 
....................       } 
....................  
....................       fputc(cs, RS485_CD); 
....................       //fputc(0xFF, RS485_CD); 
....................       if(!rs485_collision) { 
....................          ret = TRUE; 
....................          break; 
....................       } 
....................       delay_ms(RS485_ID); 
....................    } 
....................  
....................    RCV_ON(); 
....................    #if RS485_USE_EXT_INT 
....................       enable_interrupts(GLOBAL); 
....................    #endif 
....................  
....................    return(ret); 
.................... } 
....................  
....................  
.................... // Purpose:    Wait for wait time for the RS485 bus to become idle 
.................... // Inputs:     TRUE - restart the watch dog timer to prevent reset 
.................... //             FALSE - watch dog timer not restarted 
.................... // Outputs:    None 
.................... void rs485_wait_for_bus(int1 clrwdt) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    RCV_OFF(); 
....................    for(i=0; i <= (rs485_wait_time*20); ++i) 
....................    { 
....................       if(!input(RS485_RX_PIN)) 
....................          i = 0; 
....................       else 
....................          delay_us(50); 
....................  
....................       if(clrwdt) 
....................          restart_wdt(); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     1) A pointer to a buffer to store a message 
.................... //             2) TRUE  - wait for a message 
.................... //                FALSE - only check if a message is available 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if wait is FALSE and no message is available 
.................... // Note:       Data will be filled in at the pointer as follows: 
.................... //             FROM_ID  DATALENGTH  DATA... 
.................... int1 rs485_get_message(unsigned int8* data_ptr, int1 wait) 
.................... { 
....................    while(wait && (rs485_ni == rs485_no)) {} 
....................  
....................    if(rs485_ni == rs485_no) 
....................       return FALSE; 
....................    else { 
....................       int n; 
....................       n = rs485_buffer[(rs485_no+1)%sizeof(rs485_buffer)] + 2; 
....................  
....................       for(; n>0; --n) 
....................       { 
....................          *data_ptr = rs485_buffer[rs485_no]; 
....................          if(++rs485_no >= sizeof(rs485_buffer)) 
....................          { 
....................             rs485_no = 0; 
....................          } 
....................          ++data_ptr; 
....................       } 
....................       return TRUE; 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /*#######################################################################*/ 
.................... #int_TIMER0 
.................... void  TIMER0_isr(void) 				//8.192ms 
.................... { 
.................... 	++TIME_MAKER; 
009F:  INCF   27,F
....................     set_timer0(timer0_value); 
00A0:  MOVLW  84
00A1:  MOVWF  15
....................     DisplayDrive(); 
*
00CE:  BCF    0B.2
00CF:  MOVLP  00
00D0:  GOTO   01A
.................... } 
.................... /*#######################################################################*/ 
....................  
.................... void ConvertDECtoBCD(int16 decimal) 
.................... { 
....................     BCD_100=(decimal/100); 
*
0158:  MOVF   56,W
0159:  MOVWF  5B
015A:  MOVF   55,W
015B:  MOVWF  5A
015C:  CLRF   5D
015D:  MOVLW  64
015E:  MOVWF  5C
015F:  CALL   0E8
0160:  MOVF   79,W
0161:  MOVWF  35
0162:  MOVF   78,W
0163:  MOVWF  34
....................     BCD_10=((decimal-(BCD_100*100))/10); 
0164:  MOVF   35,W
0165:  MOVWF  5B
0166:  MOVF   34,W
0167:  MOVWF  5A
0168:  CLRF   5D
0169:  MOVLW  64
016A:  MOVWF  5C
016B:  CALL   10D
016C:  MOVF   79,W
016D:  MOVWF  7A
016E:  MOVF   78,W
016F:  SUBWF  55,W
0170:  MOVWF  58
0171:  MOVF   79,W
0172:  SUBWFC 56,W
0173:  MOVWF  59
0174:  MOVWF  5B
0175:  MOVF   58,W
0176:  MOVWF  5A
0177:  CLRF   5D
0178:  MOVLW  0A
0179:  MOVWF  5C
017A:  CALL   0E8
017B:  MOVF   79,W
017C:  MOVWF  37
017D:  MOVF   78,W
017E:  MOVWF  36
....................     BCD_1=((decimal-(BCD_100*100)-(BCD_10*10))); 
017F:  MOVF   35,W
0180:  MOVWF  5B
0181:  MOVF   34,W
0182:  MOVWF  5A
0183:  CLRF   5D
0184:  MOVLW  64
0185:  MOVWF  5C
0186:  CALL   10D
0187:  MOVF   79,W
0188:  MOVWF  7A
0189:  MOVF   78,W
018A:  SUBWF  55,W
018B:  MOVWF  58
018C:  MOVF   79,W
018D:  SUBWFC 56,W
018E:  MOVWF  59
018F:  MOVF   37,W
0190:  MOVWF  5B
0191:  MOVF   36,W
0192:  MOVWF  5A
0193:  CLRF   5D
0194:  MOVLW  0A
0195:  MOVWF  5C
0196:  CALL   10D
0197:  MOVF   78,W
0198:  SUBWF  58,W
0199:  MOVWF  38
019A:  MOVF   79,W
019B:  SUBWFC 59,W
019C:  MOVWF  39
.................... } 
.................... /*#######################################################################*/ 
.................... /*#######################################################################*/ 
.................... void AssignDigits(int16 value) 
....................    { 
....................        ConvertDECToBCD(value); 
*
0154:  MOVF   54,W
0155:  MOVWF  56
0156:  MOVF   53,W
0157:  MOVWF  55
....................        Convert7Segment(BCD_100); 
*
019D:  MOVF   34,W
019E:  MOVWF  55
019F:  CALL   122
....................        DIGIT_1=DIGIT_TEMP; 
01A0:  MOVF   32,W
01A1:  MOVWF  2F
....................        Convert7Segment(BCD_10); 
01A2:  MOVF   36,W
01A3:  MOVWF  55
01A4:  CALL   122
....................        DIGIT_2=DIGIT_TEMP; 
01A5:  MOVF   32,W
01A6:  MOVWF  30
....................        Convert7Segment(BCD_1); 
01A7:  MOVF   38,W
01A8:  MOVWF  55
01A9:  CALL   122
....................        DIGIT_3=DIGIT_TEMP; 
01AA:  MOVF   32,W
01AB:  MOVWF  31
01AC:  MOVLP  00
01AD:  GOTO   334 (RETURN)
....................    } 
....................  
.................... void main () 
01AE:  MOVLW  57
01AF:  MOVWF  77
01B0:  MOVLW  20
01B1:  MOVWF  04
01B2:  MOVLW  00
01B3:  MOVWF  05
01B4:  CLRF   00
01B5:  INCF   04,F
01B6:  DECFSZ 77,F
01B7:  GOTO   1B4
01B8:  CLRF   78
01B9:  CLRF   79
01BA:  CLRF   7A
01BB:  CLRF   7B
01BC:  CLRF   7C
01BD:  CLRF   7D
01BE:  CLRF   7E
01BF:  MOVLW  50
01C0:  MOVWF  77
01C1:  MOVLW  A0
01C2:  MOVWF  04
01C3:  MOVLW  00
01C4:  MOVWF  05
01C5:  CLRF   00
01C6:  INCF   04,F
01C7:  DECFSZ 77,F
01C8:  GOTO   1C5
01C9:  MOVLW  50
01CA:  MOVWF  77
01CB:  MOVLW  20
01CC:  MOVWF  04
01CD:  MOVLW  01
01CE:  MOVWF  05
01CF:  CLRF   00
01D0:  INCF   04,F
01D1:  DECFSZ 77,F
01D2:  GOTO   1CF
01D3:  CLRF   05
01D4:  MOVLW  50
01D5:  MOVWF  77
01D6:  MOVLW  A0
01D7:  MOVWF  04
01D8:  MOVLW  01
01D9:  MOVWF  05
01DA:  CLRF   00
01DB:  INCF   04,F
01DC:  DECFSZ 77,F
01DD:  GOTO   1DA
01DE:  CLRF   05
01DF:  MOVLW  50
01E0:  MOVWF  77
01E1:  MOVLW  20
01E2:  MOVWF  04
01E3:  MOVLW  02
01E4:  MOVWF  05
01E5:  CLRF   00
01E6:  INCF   04,F
01E7:  DECFSZ 77,F
01E8:  GOTO   1E5
01E9:  CLRF   05
01EA:  MOVLW  50
01EB:  MOVWF  77
01EC:  MOVLW  A0
01ED:  MOVWF  04
01EE:  MOVLW  02
01EF:  MOVWF  05
01F0:  CLRF   00
01F1:  INCF   04,F
01F2:  DECFSZ 77,F
01F3:  GOTO   1F0
01F4:  CLRF   05
01F5:  MOVLW  50
01F6:  MOVWF  77
01F7:  MOVLW  20
01F8:  MOVWF  04
01F9:  MOVLW  03
01FA:  MOVWF  05
01FB:  CLRF   00
01FC:  INCF   04,F
01FD:  DECFSZ 77,F
01FE:  GOTO   1FB
01FF:  CLRF   05
0200:  MOVLW  50
0201:  MOVWF  77
0202:  MOVLW  A0
0203:  MOVWF  04
0204:  MOVLW  03
0205:  MOVWF  05
0206:  CLRF   00
0207:  INCF   04,F
0208:  DECFSZ 77,F
0209:  GOTO   206
020A:  CLRF   05
020B:  MOVLW  50
020C:  MOVWF  77
020D:  MOVLW  20
020E:  MOVWF  04
020F:  MOVLW  04
0210:  MOVWF  05
0211:  CLRF   00
0212:  INCF   04,F
0213:  DECFSZ 77,F
0214:  GOTO   211
0215:  CLRF   05
0216:  MOVLW  50
0217:  MOVWF  77
0218:  MOVLW  A0
0219:  MOVWF  04
021A:  MOVLW  04
021B:  MOVWF  05
021C:  CLRF   00
021D:  INCF   04,F
021E:  DECFSZ 77,F
021F:  GOTO   21C
0220:  CLRF   05
0221:  MOVLW  50
0222:  MOVWF  77
0223:  MOVLW  20
0224:  MOVWF  04
0225:  MOVLW  05
0226:  MOVWF  05
0227:  CLRF   00
0228:  INCF   04,F
0229:  DECFSZ 77,F
022A:  GOTO   227
022B:  CLRF   05
022C:  MOVLW  50
022D:  MOVWF  77
022E:  MOVLW  A0
022F:  MOVWF  04
0230:  MOVLW  05
0231:  MOVWF  05
0232:  CLRF   00
0233:  INCF   04,F
0234:  DECFSZ 77,F
0235:  GOTO   232
0236:  CLRF   05
0237:  MOVLW  50
0238:  MOVWF  77
0239:  MOVLW  20
023A:  MOVWF  04
023B:  MOVLW  06
023C:  MOVWF  05
023D:  CLRF   00
023E:  INCF   04,F
023F:  DECFSZ 77,F
0240:  GOTO   23D
0241:  CLRF   05
0242:  MOVLW  50
0243:  MOVWF  77
0244:  MOVLW  A0
0245:  MOVWF  04
0246:  MOVLW  06
0247:  MOVWF  05
0248:  CLRF   00
0249:  INCF   04,F
024A:  DECFSZ 77,F
024B:  GOTO   248
024C:  CLRF   05
024D:  MOVLW  50
024E:  MOVWF  77
024F:  MOVLW  20
0250:  MOVWF  04
0251:  MOVLW  07
0252:  MOVWF  05
0253:  CLRF   00
0254:  INCF   04,F
0255:  DECFSZ 77,F
0256:  GOTO   253
0257:  CLRF   05
0258:  MOVLW  50
0259:  MOVWF  77
025A:  MOVLW  A0
025B:  MOVWF  04
025C:  MOVLW  07
025D:  MOVWF  05
025E:  CLRF   00
025F:  INCF   04,F
0260:  DECFSZ 77,F
0261:  GOTO   25E
0262:  CLRF   05
0263:  MOVLW  50
0264:  MOVWF  77
0265:  MOVLW  20
0266:  MOVWF  04
0267:  MOVLW  08
0268:  MOVWF  05
0269:  CLRF   00
026A:  INCF   04,F
026B:  DECFSZ 77,F
026C:  GOTO   269
026D:  CLRF   05
026E:  MOVLW  50
026F:  MOVWF  77
0270:  MOVLW  A0
0271:  MOVWF  04
0272:  MOVLW  08
0273:  MOVWF  05
0274:  CLRF   00
0275:  INCF   04,F
0276:  DECFSZ 77,F
0277:  GOTO   274
0278:  CLRF   05
0279:  MOVLW  50
027A:  MOVWF  77
027B:  MOVLW  20
027C:  MOVWF  04
027D:  MOVLW  09
027E:  MOVWF  05
027F:  CLRF   00
0280:  INCF   04,F
0281:  DECFSZ 77,F
0282:  GOTO   27F
0283:  CLRF   05
0284:  MOVLW  50
0285:  MOVWF  77
0286:  MOVLW  A0
0287:  MOVWF  04
0288:  MOVLW  09
0289:  MOVWF  05
028A:  CLRF   00
028B:  INCF   04,F
028C:  DECFSZ 77,F
028D:  GOTO   28A
028E:  CLRF   05
028F:  MOVLW  50
0290:  MOVWF  77
0291:  MOVLW  20
0292:  MOVWF  04
0293:  MOVLW  0A
0294:  MOVWF  05
0295:  CLRF   00
0296:  INCF   04,F
0297:  DECFSZ 77,F
0298:  GOTO   295
0299:  CLRF   05
029A:  MOVLW  50
029B:  MOVWF  77
029C:  MOVLW  A0
029D:  MOVWF  04
029E:  MOVLW  0A
029F:  MOVWF  05
02A0:  CLRF   00
02A1:  INCF   04,F
02A2:  DECFSZ 77,F
02A3:  GOTO   2A0
02A4:  CLRF   05
02A5:  MOVLW  50
02A6:  MOVWF  77
02A7:  MOVLW  20
02A8:  MOVWF  04
02A9:  MOVLW  0B
02AA:  MOVWF  05
02AB:  CLRF   00
02AC:  INCF   04,F
02AD:  DECFSZ 77,F
02AE:  GOTO   2AB
02AF:  CLRF   05
02B0:  MOVLW  50
02B1:  MOVWF  77
02B2:  MOVLW  A0
02B3:  MOVWF  04
02B4:  MOVLW  0B
02B5:  MOVWF  05
02B6:  CLRF   00
02B7:  INCF   04,F
02B8:  DECFSZ 77,F
02B9:  GOTO   2B6
02BA:  CLRF   05
02BB:  MOVLW  50
02BC:  MOVWF  77
02BD:  MOVLW  20
02BE:  MOVWF  04
02BF:  MOVLW  0C
02C0:  MOVWF  05
02C1:  CLRF   00
02C2:  INCF   04,F
02C3:  DECFSZ 77,F
02C4:  GOTO   2C1
02C5:  CLRF   05
02C6:  MOVLW  20
02C7:  MOVWF  77
02C8:  MOVLW  A0
02C9:  MOVWF  04
02CA:  MOVLW  0C
02CB:  MOVWF  05
02CC:  CLRF   00
02CD:  INCF   04,F
02CE:  DECFSZ 77,F
02CF:  GOTO   2CC
02D0:  CLRF   05
02D1:  CLRF   20
02D2:  MOVLW  7A
02D3:  MOVLB  01
02D4:  MOVWF  19
02D5:  MOVLB  02
02D6:  BCF    0C.3
02D7:  MOVLB  00
02D8:  CLRF   3A
02D9:  MOVLB  03
02DA:  BSF    1F.3
02DB:  MOVLW  A0
02DC:  MOVWF  1B
02DD:  MOVLW  01
02DE:  MOVWF  1C
02DF:  MOVLW  A6
02E0:  MOVWF  1E
02E1:  MOVLW  90
02E2:  MOVWF  1D
02E3:  MOVLB  02
02E4:  BCF    0C.3
02E5:  BSF    0E.6
02E6:  MOVLB  00
02E7:  CLRF   48
02E8:  MOVLB  03
02E9:  CLRF   0C
02EA:  CLRF   0D
02EB:  CLRF   0E
02EC:  MOVLB  02
02ED:  CLRF   12
02EE:  CLRF   11
.................... { 
.................... 	setup_oscillator(OSC_16MHZ); 
02EF:  MOVLW  78
02F0:  MOVLB  01
02F1:  MOVWF  19
.................... 	setup_timer_0(T0_INTERNAL|T0_DIV_16|T0_8_BIT);      //500us overflow 
02F2:  MOVF   15,W
02F3:  ANDLW  C0
02F4:  IORLW  03
02F5:  MOVWF  15
....................  
....................      
....................     setup_adc (ADC_OFF); 
02F6:  BCF    1D.0
....................  
....................     setup_ccp1(CCP_OFF); 
02F7:  MOVLW  F0
02F8:  MOVLB  05
02F9:  ANDWF  13,F
.................... 	setup_ccp2(CCP_OFF); 
02FA:  ANDWF  1A,F
....................     setup_ccp3(CCP_OFF);     
02FB:  MOVLB  06
02FC:  ANDWF  13,F
....................     setup_dac(DAC_OFF); 
02FD:  MOVLB  02
02FE:  CLRF   18
....................     setup_comparator_1(NC_NC); 
02FF:  MOVLW  3F
0300:  MOVWF  12
0301:  CLRF   11
....................     setup_comparator_2(NC_NC); 
0302:  MOVWF  14
0303:  CLRF   13
....................     setup_comparator_3(NC_NC); 
0304:  MOVWF  1F
0305:  CLRF   1E
....................     setup_comparator_4(NC_NC); 
0306:  MOVWF  1B
0307:  CLRF   1A
.................... 	enable_interrupts(INT_TIMER0); 
0308:  BSF    0B.5
.................... 	disable_interrupts(GLOBAL); 
0309:  BCF    0B.6
030A:  BCF    0B.7
030B:  BTFSC  0B.7
030C:  GOTO   30A
....................   
....................  
....................   	SET_TRIS_A(0b00000010); 
030D:  MOVLW  02
030E:  MOVLB  01
030F:  MOVWF  0C
.................... 	SET_TRIS_B(0b00000000); 
0310:  MOVLW  00
0311:  MOVWF  0D
.................... 	SET_TRIS_C(0b10000000); 
0312:  MOVLW  80
0313:  MOVWF  0E
.................... 	SET_TRIS_E(0b00001000); 
0314:  BSF    10.3
....................  
....................      
....................     port_c_pullups(0b11000000); 
0315:  MOVLW  C0
0316:  MOVLB  04
0317:  MOVWF  0E
0318:  MOVLB  01
0319:  BCF    15.7
....................      
....................     rs485_init(); 
031A:  MOVLB  00
031B:  GOTO   0D1
....................  
....................     enable_interrupts(GLOBAL); 
031C:  MOVLW  C0
031D:  IORWF  0B,F
....................      
....................  //   data=0b10000111; 
....................      
....................    int ahmet[]={99}; 
031E:  MOVLW  63
031F:  MOVWF  50
....................    int  veli,old_veli; 
....................      
.................... 	while(1) 
.................... 		{ 
....................             restart_wdt(); 
0320:  CLRWDT
....................  
.................... 			if	(TIME_MAKER>=2)		//1msn lik i?ler 
0321:  MOVF   27,W
0322:  SUBLW  01
0323:  BTFSC  03.0
0324:  GOTO   328
.................... 			{ 
....................                 restart_wdt(); 
0325:  CLRWDT
.................... 				TIME_MAKER=0; 
0326:  CLRF   27
.................... 				++REG_10ms; 
0327:  INCF   28,F
.................... 				/////// 
....................                  
....................  
....................                  
....................    
.................... 			}	 
....................  
.................... 			if	(REG_10ms>=10)		//10msn lik i?ler 
0328:  MOVF   28,W
0329:  SUBLW  09
032A:  BTFSC  03.0
032B:  GOTO   335
.................... 			{ 
.................... 				REG_10ms=0; 
032C:  CLRF   28
.................... 				++REG_50ms; 
032D:  INCF   29,F
.................... 				/////// 
....................                  
....................                 veli=rs485_buffer[6]; 
032E:  MOVF   44,W
032F:  MOVWF  51
....................                 AssignDigits(veli); 
0330:  CLRF   54
0331:  MOVF   51,W
0332:  MOVWF  53
0333:  GOTO   154
....................                 rs485_ni=0; 
0334:  CLRF   3C
....................                  
.................... //                if(veli!=old_veli) 
.................... //                { 
.................... //                     
.................... //                    //memset(&rs485_buffer, 0, sizeof(rs485_buffer)); 
.................... //                     
.................... ////                    delay_ms(5); 
.................... ////                    rs485_send_message(RS485_DEST_ID,1,&veli); 
.................... //                } 
.................... //                old_veli=veli;  
....................  
.................... 			}	 
....................  
.................... 			if	(REG_50ms>=5)		//50msn lik i?ler 
0335:  MOVF   29,W
0336:  SUBLW  04
0337:  BTFSC  03.0
0338:  GOTO   33B
.................... 			{ 
.................... 				REG_50ms=0; 
0339:  CLRF   29
.................... 				++REG_100ms; 
033A:  INCF   2A,F
.................... 				/////// 
.................... //                 output_toggle(LED); 
....................  
....................      		}	 
.................... 			 
.................... 			if	(REG_100ms>=2)		//100msn lik i?ler 
033B:  MOVF   2A,W
033C:  SUBLW  01
033D:  BTFSC  03.0
033E:  GOTO   341
.................... 			{ 
.................... 				REG_100ms=0; 
033F:  CLRF   2A
.................... 				++REG_500ms; 
0340:  INCF   2B,F
.................... 				/////// 
.................... //                to*=12; 
....................                  
....................  
....................                  
....................  
.................... 			}		 
.................... 		  
.................... 			if	(REG_500ms>=5)		//500msn lik i?ler 
0341:  MOVF   2B,W
0342:  SUBLW  04
0343:  BTFSC  03.0
0344:  GOTO   347
.................... 			{ 
.................... 				REG_500ms=0; 
0345:  CLRF   2B
.................... 				++REG_1s; 
0346:  INCF   2C,F
.................... 				/////// 
....................  
.................... 			}	 
.................... 		 	 
.................... 		 	if	(REG_1s>=2)		//1000msn lik i?ler 
0347:  MOVF   2C,W
0348:  SUBLW  01
0349:  BTFSS  03.0
.................... 			{ 
.................... 				REG_1s=0; 
034A:  CLRF   2C
.................... 				/////// 
.................... //                data=0b10000111; 
.................... //                ++data; 
.................... //                data=0x38; 
.................... //                rs485_wait_for_bus(TRUE); 
.................... //                rs485_send_message(RS485_DEST_ID,1,&ahmet,); 
.................... //                AssignDigits(ahmet[0]); 
....................  
....................             } 
....................          
....................             if	(REG_10s>=10)		//10 saniye lik isler 
034B:  MOVF   2D,W
034C:  SUBLW  09
034D:  BTFSS  03.0
.................... 			{ 
....................                 REG_10s=0; 
034E:  CLRF   2D
.................... 				/////// 
....................     
....................             } 
034F:  GOTO   320
....................              
.................... 		} 
.................... 		 
.................... } 
....................  
0350:  SLEEP
....................  

Configuration Fuses:
   Word  1: 0E44   INTRC_IO NOWDT PUT MCLR PROTECT CPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NOLPBOR NODEBUG NOLVP
