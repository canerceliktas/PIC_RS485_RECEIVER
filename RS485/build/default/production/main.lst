CCS PCM C Compiler, Version 5.076, 56587               18-Mar-20 09:25

               Filename:   C:\Users\Planlama\Desktop\RS485\build\default\production\main.lst

               ROM used:   1045 words (6%)
                           Largest free fragment is 2048
               RAM used:   60 (3%) at main() level
                           89 (4%) worst case
               Stack used: 0 locations
               Stack size: 16

*
0000:  MOVLP  00
0001:  GOTO   25B
0002:  NOP
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  BTFSS  0B.5
0010:  GOTO   013
0011:  BTFSC  0B.2
0012:  GOTO   023
0013:  CLRF   05
0014:  MOVLW  91
0015:  MOVWF  04
0016:  BTFSS  00.5
0017:  GOTO   01A
0018:  BTFSC  11.5
0019:  GOTO   025
001A:  MOVF   20,W
001B:  MOVWF  77
001C:  MOVF   21,W
001D:  MOVWF  78
001E:  MOVF   22,W
001F:  MOVWF  79
0020:  MOVF   23,W
0021:  MOVWF  7A
0022:  RETFIE
0023:  MOVLP  00
0024:  GOTO   09F
0025:  MOVLP  00
0026:  GOTO   04A
.................... /*  
....................  * File:   main.c 
....................  * Author: Orkun OKUR 
....................  * 
....................  * Created on 12 Subat 2020 Çarsamba, 10:58 
....................  */ 
.................... #include 	<16F1788.h> 
.................... //////////// Standard Header file for the PIC16F1788 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1788 
*
00EA:  CLRF   78
00EB:  CLRF   79
00EC:  CLRF   77
00ED:  CLRF   7A
00EE:  MOVF   61,W
00EF:  BTFSS  03.2
00F0:  GOTO   0F4
00F1:  MOVF   60,W
00F2:  BTFSC  03.2
00F3:  GOTO   10E
00F4:  MOVLW  10
00F5:  MOVWF  62
00F6:  BCF    03.0
00F7:  RLF    5E,F
00F8:  RLF    5F,F
00F9:  RLF    77,F
00FA:  RLF    7A,F
00FB:  MOVF   61,W
00FC:  SUBWF  7A,W
00FD:  BTFSS  03.2
00FE:  GOTO   101
00FF:  MOVF   60,W
0100:  SUBWF  77,W
0101:  BTFSS  03.0
0102:  GOTO   10A
0103:  MOVF   60,W
0104:  SUBWF  77,F
0105:  BTFSS  03.0
0106:  DECF   7A,F
0107:  MOVF   61,W
0108:  SUBWF  7A,F
0109:  BSF    03.0
010A:  RLF    78,F
010B:  RLF    79,F
010C:  DECFSZ 62,F
010D:  GOTO   0F6
010E:  RETURN
010F:  MOVLW  10
0110:  MOVWF  62
0111:  CLRF   77
0112:  CLRF   7A
0113:  RRF    5F,F
0114:  RRF    5E,F
0115:  BTFSS  03.0
0116:  GOTO   11D
0117:  MOVF   60,W
0118:  ADDWF  77,F
0119:  BTFSC  03.0
011A:  INCF   7A,F
011B:  MOVF   61,W
011C:  ADDWF  7A,F
011D:  RRF    7A,F
011E:  RRF    77,F
011F:  RRF    79,F
0120:  RRF    78,F
0121:  DECFSZ 62,F
0122:  GOTO   113
0123:  RETURN
*
0148:  BSF    0A.0
0149:  BCF    0A.1
014A:  BCF    0A.2
014B:  ADDWF  02,F
014C:  GOTO   12A
014D:  GOTO   12D
014E:  GOTO   130
014F:  GOTO   133
0150:  GOTO   136
0151:  GOTO   139
0152:  GOTO   13C
0153:  GOTO   13F
0154:  GOTO   142
0155:  GOTO   145
....................  
.................... #list 
....................  
.................... #device     PIC16F1788 
....................  
....................  
.................... #device 	adc=8 
.................... #FUSES      INTRC_IO, NOWDT, PUT, MCLR, PROTECT, CPD, BROWNOUT, NOCLKOUT, NOIESO, NOFCMEN, NOVCAP, BORV19  		 
.................... #use 		delay(clock=16000000) 
*
01B0:  MOVLW  20
01B1:  MOVWF  05
01B2:  MOVLW  40
01B3:  MOVWF  04
01B4:  MOVF   00,W
01B5:  BTFSC  03.2
01B6:  GOTO   1C5
01B7:  MOVLW  05
01B8:  MOVWF  78
01B9:  CLRF   77
01BA:  DECFSZ 77,F
01BB:  GOTO   1BA
01BC:  DECFSZ 78,F
01BD:  GOTO   1B9
01BE:  MOVLW  2E
01BF:  MOVWF  77
01C0:  DECFSZ 77,F
01C1:  GOTO   1C0
01C2:  GOTO   1C3
01C3:  DECFSZ 00,F
01C4:  GOTO   1B7
01C5:  RETURN
.................... //#use rs232  (baud=9600, xmit=PIN_C6, rcv=PIN_C7, ENABLE=PIN_A3, PARITY=E, STOP=1,FORCE_SW) 
.................... #use fast_io(c) 
.................... #use fast_io(a) 
.................... #ZERO_RAM 
....................  
.................... #include <stdio.h>	 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include	"Definition.h" 
.................... #define		timer1_value        61580 
.................... #define		timer0_value        132 
....................  
....................  
.................... //#define     LED         PIN_C6 
.................... #define     DIGIT1_COM  PIN_C1 
.................... #define     DIGIT2_COM  PIN_C0 
.................... #define     DIGIT3_COM  PIN_A5 
....................  
.................... #define RS485_ID    0x29  
.................... #define RS485_DEST_ID    0x17 
.................... #define RS485_RX_BUFFER_SIZE    8 
....................  
.................... #define RS485_RX_PIN       PIN_C7   // Data receive pin 
.................... #define RS485_TX_PIN       PIN_C6   // Data transmit pin 
.................... #define RS485_ENABLE_PIN   PIN_A3   // Controls DE pin.  RX low, TX high. 
....................  
....................  
....................  
....................  
.................... int1    snd; 
.................... unsigned int8   TIME_MAKER,REG_10ms,REG_50ms,REG_100ms,REG_500ms,REG_1s,REG_10s; 
.................... unsigned int8   DigitOrder,DIGIT_1,DIGIT_2,DIGIT_3,DIGIT_TEMP; 
.................... unsigned int8   data; 
.................... unsigned int16  BCD_100,BCD_10,BCD_1; 
....................  
....................  
.................... #include	"DisplayDrive.h" 
....................  
....................  
.................... void DisplayDrive() 
.................... { 
.................... 	output_low(DIGIT1_COM); 
*
00A2:  MOVLB  02
00A3:  BCF    0E.1
.................... 	output_low(DIGIT2_COM); 
00A4:  BCF    0E.0
.................... 	output_low(DIGIT3_COM); 
00A5:  BCF    0C.5
....................  
....................  
....................     switch (DigitOrder) 
00A6:  MOVLB  00
00A7:  MOVF   2F,W
00A8:  BTFSC  03.2
00A9:  GOTO   0B1
00AA:  XORLW  01
00AB:  BTFSC  03.2
00AC:  GOTO   0BB
00AD:  XORLW  03
00AE:  BTFSC  03.2
00AF:  GOTO   0C5
00B0:  GOTO   0CE
....................     { 
....................         case 0: 
....................         OUTPUT_B(DIGIT_1); 
00B1:  MOVLB  01
00B2:  CLRF   0D
00B3:  MOVLB  00
00B4:  MOVF   30,W
00B5:  MOVLB  02
00B6:  MOVWF  0D
....................         output_high(DIGIT1_COM); 
00B7:  BSF    0E.1
....................         ++DigitOrder; 
00B8:  MOVLB  00
00B9:  INCF   2F,F
....................         break; 
00BA:  GOTO   0CE
....................  
....................         case 1: 
....................         OUTPUT_B(DIGIT_2); 
00BB:  MOVLB  01
00BC:  CLRF   0D
00BD:  MOVLB  00
00BE:  MOVF   31,W
00BF:  MOVLB  02
00C0:  MOVWF  0D
....................         output_high(DIGIT2_COM); 
00C1:  BSF    0E.0
....................         ++DigitOrder; 
00C2:  MOVLB  00
00C3:  INCF   2F,F
....................         break; 
00C4:  GOTO   0CE
....................  
....................         case 2: 
....................         OUTPUT_B(DIGIT_3); 
00C5:  MOVLB  01
00C6:  CLRF   0D
00C7:  MOVLB  00
00C8:  MOVF   32,W
00C9:  MOVLB  02
00CA:  MOVWF  0D
....................         output_high(DIGIT3_COM); 
00CB:  BSF    0C.5
....................         DigitOrder=0; 
00CC:  MOVLB  00
00CD:  CLRF   2F
....................         break; 
....................  
....................      } 
.................... 	 
.................... }	 
....................  
.................... #include	"LookUpTable.h" 
.................... //       0b bfaeddpcg 
.................... void Convert7Segment(ref) 
.................... { 
.................... 	switch (ref) 
*
0124:  MOVF   59,W
0125:  ADDLW  F6
0126:  BTFSC  03.0
0127:  GOTO   147
0128:  ADDLW  0A
0129:  GOTO   148
.................... 	{ 
.................... 		case 0: 
.................... 		DIGIT_TEMP=(0b11111010); 
012A:  MOVLW  FA
012B:  MOVWF  33
.................... 		break; 
012C:  GOTO   147
....................  
.................... 		case 1: 
.................... 		DIGIT_TEMP=(0b10000010); 
012D:  MOVLW  82
012E:  MOVWF  33
.................... 		break; 
012F:  GOTO   147
....................  
.................... 		case 2: 
.................... 		DIGIT_TEMP=(0b10111001); 
0130:  MOVLW  B9
0131:  MOVWF  33
.................... 		break; 
0132:  GOTO   147
....................  
.................... 		case 3: 
.................... 		DIGIT_TEMP=(0b10101011); 
0133:  MOVLW  AB
0134:  MOVWF  33
.................... 		break; 
0135:  GOTO   147
....................  
.................... 		case 4: 
.................... 		DIGIT_TEMP=(0b11000011); 
0136:  MOVLW  C3
0137:  MOVWF  33
.................... 		break; 
0138:  GOTO   147
....................  
.................... 		case 5: 
.................... 		DIGIT_TEMP=(0b01101011); 
0139:  MOVLW  6B
013A:  MOVWF  33
.................... 		break; 
013B:  GOTO   147
....................  
.................... 		case 6: 
.................... 		DIGIT_TEMP=(0b01111011); 
013C:  MOVLW  7B
013D:  MOVWF  33
.................... 		break; 
013E:  GOTO   147
....................  
.................... 		case 7: 
.................... 		DIGIT_TEMP=(0b10100010); 
013F:  MOVLW  A2
0140:  MOVWF  33
.................... 		break; 
0141:  GOTO   147
....................  
.................... 		case 8: 
.................... 		DIGIT_TEMP=(0b11111011); 
0142:  MOVLW  FB
0143:  MOVWF  33
.................... 		break; 
0144:  GOTO   147
....................  
.................... 		case 9: 
.................... 		DIGIT_TEMP=(0b11101011); 
0145:  MOVLW  EB
0146:  MOVWF  33
.................... 		break; 
.................... 	} 
0147:  RETURN
....................  
....................  
.................... } 
....................  
.................... #include    <rs485.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                            RS485.c                              //// 
.................... ////                                                                 //// 
.................... ////      This file contains drivers for RS-485 communication        //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// int1 rs485_get_message(int* data_ptr, int wait)                 //// 
.................... ////     * Get a message from the RS485 bus                          //// 
.................... ////     * Address can be 1 - 33.                                    //// 
.................... ////     * A 1 will be returned if a parity check error occurred.    //// 
.................... ////                                                                 //// 
.................... //// int1 rs485_send_message(int to, int len, int* data)             //// 
.................... ////     * Send a message over the RS485 bus                         //// 
.................... ////     * Inputs:                                                   //// 
.................... ////          to    - Destination address                            //// 
.................... ////          len   - Message length                                 //// 
.................... ////          *data - Pointer to message                             //// 
.................... ////     * Returns TRUE if successful, FALSE if failed               //// 
.................... ////                                                                 //// 
.................... //// void rs485_wait_for_bus(int1 clrwdt)                            //// 
.................... ////     * Wait for the RS485 bus to open. Normally used before      //// 
.................... ////       sending a message to avoid collisions.                    //// 
.................... ////     * Pass in TRUE to restart the watch dog timer to prevent    //// 
.................... ////       the device from resetting.                                //// 
.................... ////     * This is not needed if sending an immediate response       //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef RS485_DRIVER 
.................... #define RS485_DRIVER 
....................  
.................... #ifndef RS485_ID 
.................... #define RS485_ID  0x10                 // The device's RS485 address or ID 
.................... #endif 
....................  
.................... #ifndef RS485_USE_EXT_INT 
.................... #define RS485_USE_EXT_INT FALSE        // Select between external interrupt 
.................... #endif                                 // or asynchronous serial interrupt 
....................  
....................  
.................... #if(RS485_USE_EXT_INT == FALSE) 
....................    #ifndef RS485_RX_PIN 
....................    #define RS485_RX_PIN       PIN_C7   // Data receive pin 
....................    #endif 
....................  
....................    #ifndef RS485_TX_PIN 
....................    #define RS485_TX_PIN       PIN_C6   // Data transmit pin 
....................    #endif 
....................  
....................    #ifndef RS485_ENABLE_PIN 
....................    #define RS485_ENABLE_PIN   PIN_B4   // Controls DE pin.  RX low, TX high. 
....................    #endif 
....................  
....................    #ifndef RS485_RX_ENABLE 
....................    #define RS485_RX_ENABLE    PIN_B5   // Controls RE pin.  Should keep low. 
....................    #endif 
....................  
....................    #use rs232(baud=9600, xmit=RS485_TX_PIN, rcv=RS485_RX_PIN, enable=RS485_ENABLE_PIN, bits=8, long_data, errors, stream=RS485) 
*
0027:  BTFSS  11.5
0028:  GOTO   027
0029:  MOVLB  03
002A:  MOVF   1D,W
002B:  MOVLB  00
002C:  MOVWF  3B
002D:  MOVLW  01
002E:  MOVLB  03
002F:  ANDWF  1D,W
0030:  MOVWF  79
0031:  MOVF   19,W
0032:  MOVWF  78
0033:  MOVLB  00
0034:  BTFSS  3B.1
0035:  GOTO   039
0036:  MOVLB  03
0037:  BCF    1D.4
0038:  BSF    1D.4
0039:  MOVLB  00
003A:  RETURN
....................    #use rs232(baud=9600, xmit=RS485_TX_PIN, rcv=RS485_RX_PIN, enable=RS485_ENABLE_PIN, bits=8, long_data, force_sw, multi_master, errors, stream=RS485_CD) 
*
01C6:  BTFSC  3B.6
01C7:  GOTO   204
01C8:  MOVLB  02
01C9:  BSF    0C.3
01CA:  BCF    0E.6
01CB:  MOVLW  08
01CC:  MOVWF  78
01CD:  GOTO   1CE
01CE:  NOP
01CF:  BSF    78.7
01D0:  GOTO   1F1
01D1:  BCF    78.7
01D2:  MOVLB  00
01D3:  RRF    62,F
01D4:  MOVLB  02
01D5:  BTFSC  03.0
01D6:  BSF    0E.6
01D7:  BTFSS  03.0
01D8:  BCF    0E.6
01D9:  MOVLB  00
01DA:  BTFSS  0E.6
01DB:  GOTO   1E0
01DC:  BTFSC  0E.7
01DD:  GOTO   1E1
01DE:  BSF    3B.6
01DF:  GOTO   204
01E0:  NOP
01E1:  BSF    78.6
01E2:  GOTO   1F6
01E3:  BCF    78.6
01E4:  BTFSS  0E.6
01E5:  GOTO   1EA
01E6:  BTFSC  0E.7
01E7:  GOTO   1EB
01E8:  BSF    3B.6
01E9:  GOTO   204
01EA:  NOP
01EB:  DECFSZ 78,F
01EC:  GOTO   1D3
01ED:  GOTO   1EE
01EE:  NOP
01EF:  MOVLB  02
01F0:  BSF    0E.6
01F1:  MOVLW  02
01F2:  MOVWF  04
01F3:  DECFSZ 04,F
01F4:  GOTO   1F3
01F5:  MOVLB  00
01F6:  MOVLW  80
01F7:  MOVWF  04
01F8:  DECFSZ 04,F
01F9:  GOTO   1F8
01FA:  GOTO   1FB
01FB:  NOP
01FC:  BTFSS  78.7
01FD:  GOTO   200
01FE:  MOVLB  02
01FF:  GOTO   1D1
0200:  BTFSC  78.6
0201:  GOTO   1E3
0202:  MOVLB  02
0203:  BCF    0C.3
0204:  MOVLB  00
0205:  RETURN
....................  
....................    #if getenv("AUART") 
....................       #define RCV_OFF() {setup_uart(FALSE);} 
....................    #else 
....................       #define RCV_OFF() {setup_uart(FALSE);} 
....................    #endif 
.................... #else 
....................    #ifndef RS485_RX_PIN 
....................    #define RS485_RX_PIN       PIN_B0   // Data receive pin 
....................    #endif 
....................  
....................    #ifndef RS485_TX_PIN 
....................    #define RS485_TX_PIN       PIN_B3   // Data transmit pin 
....................    #endif 
....................  
....................    #ifndef RS485_ENABLE_PIN 
....................    #define RS485_ENABLE_PIN   PIN_B4   // Controls DE pin.  RX low, TX high. 
....................    #endif 
....................  
....................    #ifndef RS485_RX_ENABLE 
....................    #define RS485_RX_ENABLE    PIN_B5   // Controls RE pin.  Should keep low. 
....................    #endif 
....................  
....................    #use rs232(baud=9600, xmit=RS485_TX_PIN, rcv=RS485_RX_PIN, enable=RS485_ENABLE_PIN, bits=9, long_data, errors, stream=RS485) 
....................    #use rs232(baud=9600, xmit=RS485_TX_PIN, rcv=RS485_RX_PIN, enable=RS485_ENABLE_PIN, bits=9, long_data, multi_master, errors, stream=RS485_CD) 
....................  
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);} 
.................... #endif 
....................  
....................  
....................  
.................... #define RS485_wait_time 20             // Wait time in milliseconds 
....................  
.................... #bit    rs485_collision = rs232_errors.6 
....................  
.................... #ifndef RS485_RX_BUFFER_SIZE 
.................... #define RS485_RX_BUFFER_SIZE  8 
.................... #endif 
....................  
.................... unsigned int8 rs485_state, rs485_ni, rs485_no; 
.................... unsigned int8 rs485_buffer[RS485_RX_BUFFER_SIZE]; 
....................  
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
....................    #if (RS485_USE_EXT_INT==FALSE) 
....................       while(kbhit(RS485)) {getc();} // Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
*
00D1:  BTFSS  11.5
00D2:  GOTO   0D5
00D3:  CALL   027
....................       #if getenv("AUART") 
00D4:  GOTO   0D1
....................          setup_uart(UART_ADDRESS); 
00D5:  MOVLB  03
00D6:  BSF    1D.3
....................          setup_uart(TRUE); 
00D7:  BSF    1D.7
00D8:  BSF    1D.4
00D9:  BSF    1E.5
....................       #else 
....................          setup_uart(TRUE); 
....................       #endif 
....................    #else 
00DA:  MOVLB  00
00DB:  RETURN
....................       clear_interrupt(INT_EXT); 
....................       enable_interrupts(INT_EXT); 
....................    #endif 
.................... } 
....................  
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void rs485_init() { 
....................    RCV_ON(); 
00DC:  CALL   0D1
....................    rs485_state=0; 
00DD:  CLRF   3C
....................    rs485_ni=0; 
00DE:  CLRF   3D
....................    rs485_no=0; 
00DF:  CLRF   3E
....................    #if RS485_USE_EXT_INT==FALSE 
....................    enable_interrupts(INT_RDA); 
00E0:  MOVLB  01
00E1:  BSF    11.5
....................    #else 
....................    ext_int_edge(H_TO_L); 
....................    enable_interrupts(INT_EXT); 
....................    #endif 
....................    enable_interrupts(GLOBAL); 
00E2:  MOVLW  C0
00E3:  IORWF  0B,F
....................    output_low(RS485_RX_ENABLE); 
00E4:  BCF    0D.5
00E5:  MOVLB  02
00E6:  BCF    0D.5
00E7:  MOVLP  00
00E8:  MOVLB  00
00E9:  GOTO   3C9 (RETURN)
.................... } 
....................  
....................  
.................... // The index for the temporary receive buffer 
.................... unsigned int8 temp_ni; 
....................  
.................... // Purpose:    Add a byte of data to the temporary receive buffer 
.................... // Inputs:     The byte of data 
.................... // Outputs:    None 
.................... void rs485_add_to_temp(unsigned int8 b) { 
....................    // Store the byte 
....................    rs485_buffer[temp_ni] = b; 
*
003B:  MOVLW  1F
003C:  ADDWF  47,W
003D:  MOVWF  04
003E:  MOVLW  20
003F:  MOVWF  05
0040:  BTFSC  03.0
0041:  INCF   05,F
0042:  MOVF   66,W
0043:  MOVWF  00
....................  
....................    // Make the index cyclic 
....................    if(++temp_ni >= RS485_RX_BUFFER_SIZE) 
0044:  INCF   47,F
0045:  MOVF   47,W
0046:  SUBLW  07
0047:  BTFSS  03.0
....................    { 
....................       temp_ni = 0; 
0048:  CLRF   47
....................    } 
0049:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:    Interrupt service routine for handling incoming RS485 data 
.................... #if (RS485_USE_EXT_INT==FALSE) 
.................... #int_rda 
.................... #else 
.................... #int_ext 
.................... #endif 
.................... void incomming_rs485() { 
....................    unsigned int16 b; 
....................    static unsigned int8  cs,state=0,len,info,data_address; 
....................    static unsigned int16 to,source; 
....................  
....................    b=fgetc(RS485); 
004A:  CALL   027
004B:  MOVF   79,W
004C:  MOVWF  65
004D:  MOVF   78,W
004E:  MOVWF  64
....................    cs^=(unsigned int8)b; 
004F:  MOVF   64,W
0050:  XORWF  48,F
....................  
....................    switch(state) { 
0051:  MOVF   49,W
0052:  BTFSC  03.2
0053:  GOTO   061
0054:  XORLW  01
0055:  BTFSC  03.2
0056:  GOTO   06D
0057:  XORLW  03
0058:  BTFSC  03.2
0059:  GOTO   078
005A:  XORLW  01
005B:  BTFSC  03.2
005C:  GOTO   07E
005D:  XORLW  FC
005E:  BTFSC  03.2
005F:  GOTO   086
0060:  GOTO   08D
....................       case 0:  // Get from address 
....................          temp_ni=rs485_ni; 
0061:  MOVF   3D,W
0062:  MOVWF  47
....................          source=b; 
0063:  MOVF   65,W
0064:  MOVWF  50
0065:  MOVF   64,W
0066:  MOVWF  4F
....................          cs=b; 
0067:  MOVF   64,W
0068:  MOVWF  48
....................          rs485_add_to_temp(source); 
0069:  MOVF   4F,W
006A:  MOVWF  66
006B:  CALL   03B
....................          break; 
006C:  GOTO   091
....................  
....................       case 1:  // Get to address 
....................          to=b; 
006D:  MOVF   65,W
006E:  MOVWF  4E
006F:  MOVF   64,W
0070:  MOVWF  4D
....................          rs485_add_to_temp(to); 
0071:  MOVF   4D,W
0072:  MOVWF  66
0073:  CALL   03B
....................          #if (getenv("AUART")&&(RS485_USE_EXT_INT==FALSE)) 
....................             setup_uart(UART_DATA); 
0074:  MOVLB  03
0075:  BCF    1D.3
....................          #endif 
....................          break; 
0076:  MOVLB  00
0077:  GOTO   091
....................           
....................        case 2: 
....................         data_address = b; 
0078:  MOVF   64,W
0079:  MOVWF  4C
....................         rs485_add_to_temp(data_address); 
007A:  MOVF   4C,W
007B:  MOVWF  66
007C:  CALL   03B
....................        break; 
007D:  GOTO   091
....................  
....................        case 3:  // Get len 
....................          info=b; 
007E:  MOVF   64,W
007F:  MOVWF  4B
....................          len=3; 
0080:  MOVLW  03
0081:  MOVWF  4A
....................          rs485_add_to_temp(info); 
0082:  MOVF   4B,W
0083:  MOVWF  66
0084:  CALL   03B
....................          break; 
0085:  GOTO   091
....................  
....................       case 255:   // Get checksum 
....................          //if ((!cs)&&(bit_test(to,8))&&(bit_test(source,8))&&((unsigned int8)to==RS485_ID)) {  // If cs==0, then checksum is good 
....................             rs485_ni=temp_ni; 
0086:  MOVF   47,W
0087:  MOVWF  3D
....................          //} 
....................  
....................          #if (getenv("AUART")&&(RS485_USE_EXT_INT==FALSE)) 
....................             setup_uart(UART_ADDRESS); 
0088:  MOVLB  03
0089:  BSF    1D.3
....................          #endif 
....................  
....................          state=0; 
008A:  MOVLB  00
008B:  CLRF   49
....................          return; 
008C:  GOTO   09C
....................  
....................       default: // Get data 
....................          rs485_add_to_temp(b); 
008D:  MOVF   64,W
008E:  MOVWF  66
008F:  CALL   03B
....................          --len; 
0090:  DECF   4A,F
....................          break; 
....................    } 
....................    if ((state>=4) && (len==0)) { 
0091:  MOVF   49,W
0092:  SUBLW  03
0093:  BTFSC  03.0
0094:  GOTO   09B
0095:  MOVF   4A,F
0096:  BTFSS  03.2
0097:  GOTO   09B
....................       state=255; 
0098:  MOVLW  FF
0099:  MOVWF  49
....................    } 
009A:  GOTO   09C
....................    else { 
....................       ++state; 
009B:  INCF   49,F
....................    } 
009C:  BCF    11.5
009D:  MOVLP  00
009E:  GOTO   01A
.................... } 
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... int1 rs485_send_message(unsigned int8 to, unsigned int8 len, unsigned int8* data) { 
*
0206:  BCF    5E.0
....................    unsigned int8 try, i, cs; 
....................    int1 ret = FALSE; 
....................  
....................    RCV_OFF(); 
0207:  MOVLB  03
0208:  BCF    1D.7
0209:  BCF    1D.4
020A:  BCF    1E.5
....................    #if RS485_USE_EXT_INT 
....................       disable_interrupts(GLOBAL); 
....................    #endif 
....................  
....................    for(try=0; try<5; ++try) { 
020B:  MOVLB  00
020C:  CLRF   5B
020D:  MOVF   5B,W
020E:  SUBLW  04
020F:  BTFSS  03.0
0210:  GOTO   254
....................       rs485_collision = 0; 
0211:  BCF    3B.6
....................       fputc((unsigned int16)0x100|rs485_id, RS485_CD); 
0212:  MOVLW  01
0213:  MOVWF  63
0214:  MOVLW  29
0215:  MOVWF  62
0216:  CALL   1C6
....................       fputc((unsigned int16)0x100|to, RS485_CD); 
0217:  MOVF   57,W
0218:  MOVWF  60
0219:  MOVLW  01
021A:  MOVWF  61
021B:  MOVWF  63
021C:  MOVF   57,W
021D:  MOVWF  62
021E:  CALL   1C6
....................       fputc(rs485_buffer[2], RS485_CD); 
021F:  CLRF   63
0220:  MOVF   41,W
0221:  MOVWF  62
0222:  CALL   1C6
....................       fputc(len, RS485_CD); 
0223:  CLRF   63
0224:  MOVF   58,W
0225:  MOVWF  62
0226:  CALL   1C6
....................  
....................       for(i=0, cs=rs485_id^to^len; i<len; ++i) { 
0227:  CLRF   5C
0228:  MOVF   57,W
0229:  XORLW  29
022A:  XORWF  58,W
022B:  MOVWF  5D
022C:  MOVF   58,W
022D:  SUBWF  5C,W
022E:  BTFSC  03.0
022F:  GOTO   247
....................          cs ^= *data; 
0230:  MOVF   59,W
0231:  MOVWF  04
0232:  MOVF   5A,W
0233:  MOVWF  05
0234:  MOVF   00,W
0235:  XORWF  5D,F
....................          fputc(*data, RS485_CD); 
0236:  MOVF   5A,W
0237:  MOVWF  7A
0238:  MOVF   59,W
0239:  MOVWF  04
023A:  MOVF   5A,W
023B:  MOVWF  05
023C:  MOVF   00,W
023D:  MOVWF  60
023E:  CLRF   63
023F:  MOVF   60,W
0240:  MOVWF  62
0241:  CALL   1C6
....................          ++data; 
0242:  INCF   59,F
0243:  BTFSC  03.2
0244:  INCF   5A,F
0245:  INCF   5C,F
0246:  GOTO   22C
....................       } 
....................  
....................       fputc(cs, RS485_CD); 
0247:  CLRF   63
0248:  MOVF   5D,W
0249:  MOVWF  62
024A:  CALL   1C6
....................        
....................       if(!rs485_collision) { 
024B:  BTFSC  3B.6
024C:  GOTO   24F
....................          ret = TRUE; 
024D:  BSF    5E.0
....................          break; 
024E:  GOTO   254
....................       } 
....................       delay_ms(RS485_ID); 
024F:  MOVLW  29
0250:  MOVWF  60
0251:  CALL   1B0
0252:  INCF   5B,F
0253:  GOTO   20D
....................    } 
....................  
....................    RCV_ON(); 
0254:  CALL   0D1
....................    #if RS485_USE_EXT_INT 
....................       enable_interrupts(GLOBAL); 
....................    #endif 
....................  
....................    return(ret); 
0255:  MOVLW  00
0256:  BTFSC  5E.0
0257:  MOVLW  01
0258:  MOVWF  78
0259:  MOVLP  00
025A:  GOTO   3F8 (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:    Wait for wait time for the RS485 bus to become idle 
.................... // Inputs:     TRUE - restart the watch dog timer to prevent reset 
.................... //             FALSE - watch dog timer not restarted 
.................... // Outputs:    None 
.................... void rs485_wait_for_bus(int1 clrwdt) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    RCV_OFF(); 
....................    for(i=0; i <= (rs485_wait_time*20); ++i) 
....................    { 
....................       if(!input(RS485_RX_PIN)) 
....................          i = 0; 
....................       else 
....................          delay_us(50); 
....................  
....................       if(clrwdt) 
....................          restart_wdt(); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     1) A pointer to a buffer to store a message 
.................... //             2) TRUE  - wait for a message 
.................... //                FALSE - only check if a message is available 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if wait is FALSE and no message is available 
.................... // Note:       Data will be filled in at the pointer as follows: 
.................... //             FROM_ID  DATALENGTH  DATA... 
.................... int1 rs485_get_message(unsigned int8* data_ptr, int1 wait) 
.................... { 
....................    while(wait && (rs485_ni == rs485_no)) {} 
....................  
....................    if(rs485_ni == rs485_no) 
....................       return FALSE; 
....................    else { 
....................       int n; 
....................       n = rs485_buffer[(rs485_no+1)%sizeof(rs485_buffer)] + 2; 
....................  
....................       for(; n>0; --n) 
....................       { 
....................          *data_ptr = rs485_buffer[rs485_no]; 
....................          if(++rs485_no >= sizeof(rs485_buffer)) 
....................          { 
....................             rs485_no = 0; 
....................          } 
....................          ++data_ptr; 
....................       } 
....................       return TRUE; 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /*#######################################################################*/ 
.................... #int_TIMER0 
.................... void  TIMER0_isr(void) 				//8.192ms 
.................... { 
.................... 	++TIME_MAKER; 
*
009F:  INCF   28,F
....................     set_timer0(timer0_value); 
00A0:  MOVLW  84
00A1:  MOVWF  15
....................     DisplayDrive(); 
*
00CE:  BCF    0B.2
00CF:  MOVLP  00
00D0:  GOTO   01A
.................... } 
.................... /*#######################################################################*/ 
....................  
.................... void ConvertDECtoBCD(int16 decimal) 
.................... { 
....................     BCD_100=(decimal/100); 
*
015A:  MOVF   5A,W
015B:  MOVWF  5F
015C:  MOVF   59,W
015D:  MOVWF  5E
015E:  CLRF   61
015F:  MOVLW  64
0160:  MOVWF  60
0161:  CALL   0EA
0162:  MOVF   79,W
0163:  MOVWF  36
0164:  MOVF   78,W
0165:  MOVWF  35
....................     BCD_10=((decimal-(BCD_100*100))/10); 
0166:  MOVF   36,W
0167:  MOVWF  5F
0168:  MOVF   35,W
0169:  MOVWF  5E
016A:  CLRF   61
016B:  MOVLW  64
016C:  MOVWF  60
016D:  CALL   10F
016E:  MOVF   79,W
016F:  MOVWF  7A
0170:  MOVF   78,W
0171:  SUBWF  59,W
0172:  MOVWF  5C
0173:  MOVF   79,W
0174:  SUBWFC 5A,W
0175:  MOVWF  5D
0176:  MOVWF  5F
0177:  MOVF   5C,W
0178:  MOVWF  5E
0179:  CLRF   61
017A:  MOVLW  0A
017B:  MOVWF  60
017C:  CALL   0EA
017D:  MOVF   79,W
017E:  MOVWF  38
017F:  MOVF   78,W
0180:  MOVWF  37
....................     BCD_1=((decimal-(BCD_100*100)-(BCD_10*10))); 
0181:  MOVF   36,W
0182:  MOVWF  5F
0183:  MOVF   35,W
0184:  MOVWF  5E
0185:  CLRF   61
0186:  MOVLW  64
0187:  MOVWF  60
0188:  CALL   10F
0189:  MOVF   79,W
018A:  MOVWF  7A
018B:  MOVF   78,W
018C:  SUBWF  59,W
018D:  MOVWF  5C
018E:  MOVF   79,W
018F:  SUBWFC 5A,W
0190:  MOVWF  5D
0191:  MOVF   38,W
0192:  MOVWF  5F
0193:  MOVF   37,W
0194:  MOVWF  5E
0195:  CLRF   61
0196:  MOVLW  0A
0197:  MOVWF  60
0198:  CALL   10F
0199:  MOVF   78,W
019A:  SUBWF  5C,W
019B:  MOVWF  39
019C:  MOVF   79,W
019D:  SUBWFC 5D,W
019E:  MOVWF  3A
.................... } 
.................... /*#######################################################################*/ 
.................... /*#######################################################################*/ 
.................... void AssignDigits(int16 value) 
....................    { 
....................        ConvertDECToBCD(value); 
*
0156:  MOVF   58,W
0157:  MOVWF  5A
0158:  MOVF   57,W
0159:  MOVWF  59
....................        Convert7Segment(BCD_100); 
*
019F:  MOVF   35,W
01A0:  MOVWF  59
01A1:  CALL   124
....................        DIGIT_1=DIGIT_TEMP; 
01A2:  MOVF   33,W
01A3:  MOVWF  30
....................        Convert7Segment(BCD_10); 
01A4:  MOVF   37,W
01A5:  MOVWF  59
01A6:  CALL   124
....................        DIGIT_2=DIGIT_TEMP; 
01A7:  MOVF   33,W
01A8:  MOVWF  31
....................        Convert7Segment(BCD_1); 
01A9:  MOVF   39,W
01AA:  MOVWF  59
01AB:  CALL   124
....................        DIGIT_3=DIGIT_TEMP; 
01AC:  MOVF   33,W
01AD:  MOVWF  32
01AE:  MOVLP  00
01AF:  GOTO   3E7 (RETURN)
....................    } 
....................  
.................... void main () 
*
025B:  MOVLW  57
025C:  MOVWF  77
025D:  MOVLW  20
025E:  MOVWF  04
025F:  MOVLW  00
0260:  MOVWF  05
0261:  CLRF   00
0262:  INCF   04,F
0263:  DECFSZ 77,F
0264:  GOTO   261
0265:  CLRF   78
0266:  CLRF   79
0267:  CLRF   7A
0268:  CLRF   7B
0269:  CLRF   7C
026A:  CLRF   7D
026B:  CLRF   7E
026C:  MOVLW  50
026D:  MOVWF  77
026E:  MOVLW  A0
026F:  MOVWF  04
0270:  MOVLW  00
0271:  MOVWF  05
0272:  CLRF   00
0273:  INCF   04,F
0274:  DECFSZ 77,F
0275:  GOTO   272
0276:  MOVLW  50
0277:  MOVWF  77
0278:  MOVLW  20
0279:  MOVWF  04
027A:  MOVLW  01
027B:  MOVWF  05
027C:  CLRF   00
027D:  INCF   04,F
027E:  DECFSZ 77,F
027F:  GOTO   27C
0280:  CLRF   05
0281:  MOVLW  50
0282:  MOVWF  77
0283:  MOVLW  A0
0284:  MOVWF  04
0285:  MOVLW  01
0286:  MOVWF  05
0287:  CLRF   00
0288:  INCF   04,F
0289:  DECFSZ 77,F
028A:  GOTO   287
028B:  CLRF   05
028C:  MOVLW  50
028D:  MOVWF  77
028E:  MOVLW  20
028F:  MOVWF  04
0290:  MOVLW  02
0291:  MOVWF  05
0292:  CLRF   00
0293:  INCF   04,F
0294:  DECFSZ 77,F
0295:  GOTO   292
0296:  CLRF   05
0297:  MOVLW  50
0298:  MOVWF  77
0299:  MOVLW  A0
029A:  MOVWF  04
029B:  MOVLW  02
029C:  MOVWF  05
029D:  CLRF   00
029E:  INCF   04,F
029F:  DECFSZ 77,F
02A0:  GOTO   29D
02A1:  CLRF   05
02A2:  MOVLW  50
02A3:  MOVWF  77
02A4:  MOVLW  20
02A5:  MOVWF  04
02A6:  MOVLW  03
02A7:  MOVWF  05
02A8:  CLRF   00
02A9:  INCF   04,F
02AA:  DECFSZ 77,F
02AB:  GOTO   2A8
02AC:  CLRF   05
02AD:  MOVLW  50
02AE:  MOVWF  77
02AF:  MOVLW  A0
02B0:  MOVWF  04
02B1:  MOVLW  03
02B2:  MOVWF  05
02B3:  CLRF   00
02B4:  INCF   04,F
02B5:  DECFSZ 77,F
02B6:  GOTO   2B3
02B7:  CLRF   05
02B8:  MOVLW  50
02B9:  MOVWF  77
02BA:  MOVLW  20
02BB:  MOVWF  04
02BC:  MOVLW  04
02BD:  MOVWF  05
02BE:  CLRF   00
02BF:  INCF   04,F
02C0:  DECFSZ 77,F
02C1:  GOTO   2BE
02C2:  CLRF   05
02C3:  MOVLW  50
02C4:  MOVWF  77
02C5:  MOVLW  A0
02C6:  MOVWF  04
02C7:  MOVLW  04
02C8:  MOVWF  05
02C9:  CLRF   00
02CA:  INCF   04,F
02CB:  DECFSZ 77,F
02CC:  GOTO   2C9
02CD:  CLRF   05
02CE:  MOVLW  50
02CF:  MOVWF  77
02D0:  MOVLW  20
02D1:  MOVWF  04
02D2:  MOVLW  05
02D3:  MOVWF  05
02D4:  CLRF   00
02D5:  INCF   04,F
02D6:  DECFSZ 77,F
02D7:  GOTO   2D4
02D8:  CLRF   05
02D9:  MOVLW  50
02DA:  MOVWF  77
02DB:  MOVLW  A0
02DC:  MOVWF  04
02DD:  MOVLW  05
02DE:  MOVWF  05
02DF:  CLRF   00
02E0:  INCF   04,F
02E1:  DECFSZ 77,F
02E2:  GOTO   2DF
02E3:  CLRF   05
02E4:  MOVLW  50
02E5:  MOVWF  77
02E6:  MOVLW  20
02E7:  MOVWF  04
02E8:  MOVLW  06
02E9:  MOVWF  05
02EA:  CLRF   00
02EB:  INCF   04,F
02EC:  DECFSZ 77,F
02ED:  GOTO   2EA
02EE:  CLRF   05
02EF:  MOVLW  50
02F0:  MOVWF  77
02F1:  MOVLW  A0
02F2:  MOVWF  04
02F3:  MOVLW  06
02F4:  MOVWF  05
02F5:  CLRF   00
02F6:  INCF   04,F
02F7:  DECFSZ 77,F
02F8:  GOTO   2F5
02F9:  CLRF   05
02FA:  MOVLW  50
02FB:  MOVWF  77
02FC:  MOVLW  20
02FD:  MOVWF  04
02FE:  MOVLW  07
02FF:  MOVWF  05
0300:  CLRF   00
0301:  INCF   04,F
0302:  DECFSZ 77,F
0303:  GOTO   300
0304:  CLRF   05
0305:  MOVLW  50
0306:  MOVWF  77
0307:  MOVLW  A0
0308:  MOVWF  04
0309:  MOVLW  07
030A:  MOVWF  05
030B:  CLRF   00
030C:  INCF   04,F
030D:  DECFSZ 77,F
030E:  GOTO   30B
030F:  CLRF   05
0310:  MOVLW  50
0311:  MOVWF  77
0312:  MOVLW  20
0313:  MOVWF  04
0314:  MOVLW  08
0315:  MOVWF  05
0316:  CLRF   00
0317:  INCF   04,F
0318:  DECFSZ 77,F
0319:  GOTO   316
031A:  CLRF   05
031B:  MOVLW  50
031C:  MOVWF  77
031D:  MOVLW  A0
031E:  MOVWF  04
031F:  MOVLW  08
0320:  MOVWF  05
0321:  CLRF   00
0322:  INCF   04,F
0323:  DECFSZ 77,F
0324:  GOTO   321
0325:  CLRF   05
0326:  MOVLW  50
0327:  MOVWF  77
0328:  MOVLW  20
0329:  MOVWF  04
032A:  MOVLW  09
032B:  MOVWF  05
032C:  CLRF   00
032D:  INCF   04,F
032E:  DECFSZ 77,F
032F:  GOTO   32C
0330:  CLRF   05
0331:  MOVLW  50
0332:  MOVWF  77
0333:  MOVLW  A0
0334:  MOVWF  04
0335:  MOVLW  09
0336:  MOVWF  05
0337:  CLRF   00
0338:  INCF   04,F
0339:  DECFSZ 77,F
033A:  GOTO   337
033B:  CLRF   05
033C:  MOVLW  50
033D:  MOVWF  77
033E:  MOVLW  20
033F:  MOVWF  04
0340:  MOVLW  0A
0341:  MOVWF  05
0342:  CLRF   00
0343:  INCF   04,F
0344:  DECFSZ 77,F
0345:  GOTO   342
0346:  CLRF   05
0347:  MOVLW  50
0348:  MOVWF  77
0349:  MOVLW  A0
034A:  MOVWF  04
034B:  MOVLW  0A
034C:  MOVWF  05
034D:  CLRF   00
034E:  INCF   04,F
034F:  DECFSZ 77,F
0350:  GOTO   34D
0351:  CLRF   05
0352:  MOVLW  50
0353:  MOVWF  77
0354:  MOVLW  20
0355:  MOVWF  04
0356:  MOVLW  0B
0357:  MOVWF  05
0358:  CLRF   00
0359:  INCF   04,F
035A:  DECFSZ 77,F
035B:  GOTO   358
035C:  CLRF   05
035D:  MOVLW  50
035E:  MOVWF  77
035F:  MOVLW  A0
0360:  MOVWF  04
0361:  MOVLW  0B
0362:  MOVWF  05
0363:  CLRF   00
0364:  INCF   04,F
0365:  DECFSZ 77,F
0366:  GOTO   363
0367:  CLRF   05
0368:  MOVLW  50
0369:  MOVWF  77
036A:  MOVLW  20
036B:  MOVWF  04
036C:  MOVLW  0C
036D:  MOVWF  05
036E:  CLRF   00
036F:  INCF   04,F
0370:  DECFSZ 77,F
0371:  GOTO   36E
0372:  CLRF   05
0373:  MOVLW  20
0374:  MOVWF  77
0375:  MOVLW  A0
0376:  MOVWF  04
0377:  MOVLW  0C
0378:  MOVWF  05
0379:  CLRF   00
037A:  INCF   04,F
037B:  DECFSZ 77,F
037C:  GOTO   379
037D:  CLRF   05
037E:  CLRF   20
037F:  MOVLW  7A
0380:  MOVLB  01
0381:  MOVWF  19
0382:  MOVLB  02
0383:  BCF    0C.3
0384:  MOVLB  00
0385:  CLRF   3B
0386:  MOVLB  03
0387:  BSF    1F.3
0388:  MOVLW  A0
0389:  MOVWF  1B
038A:  MOVLW  01
038B:  MOVWF  1C
038C:  MOVLW  A6
038D:  MOVWF  1E
038E:  MOVLW  90
038F:  MOVWF  1D
0390:  MOVLB  02
0391:  BCF    0C.3
0392:  BSF    0E.6
0393:  MOVLB  00
0394:  CLRF   49
0395:  MOVLB  03
0396:  CLRF   0C
0397:  CLRF   0D
0398:  CLRF   0E
0399:  MOVLB  02
039A:  CLRF   12
039B:  CLRF   11
.................... { 
.................... 	setup_oscillator(OSC_16MHZ); 
039C:  MOVLW  78
039D:  MOVLB  01
039E:  MOVWF  19
.................... 	setup_timer_0(T0_INTERNAL|T0_DIV_16|T0_8_BIT);      //500us overflow 
039F:  MOVF   15,W
03A0:  ANDLW  C0
03A1:  IORLW  03
03A2:  MOVWF  15
....................  
....................      
....................     setup_adc (ADC_OFF); 
03A3:  BCF    1D.0
....................  
....................     setup_ccp1(CCP_OFF); 
03A4:  MOVLW  F0
03A5:  MOVLB  05
03A6:  ANDWF  13,F
.................... 	setup_ccp2(CCP_OFF); 
03A7:  ANDWF  1A,F
....................     setup_ccp3(CCP_OFF);     
03A8:  MOVLB  06
03A9:  ANDWF  13,F
....................     setup_dac(DAC_OFF); 
03AA:  MOVLB  02
03AB:  CLRF   18
....................     setup_comparator_1(NC_NC); 
03AC:  MOVLW  3F
03AD:  MOVWF  12
03AE:  CLRF   11
....................     setup_comparator_2(NC_NC); 
03AF:  MOVWF  14
03B0:  CLRF   13
....................     setup_comparator_3(NC_NC); 
03B1:  MOVWF  1F
03B2:  CLRF   1E
....................     setup_comparator_4(NC_NC); 
03B3:  MOVWF  1B
03B4:  CLRF   1A
.................... 	enable_interrupts(INT_TIMER0); 
03B5:  BSF    0B.5
.................... 	disable_interrupts(GLOBAL); 
03B6:  BCF    0B.6
03B7:  BCF    0B.7
03B8:  BTFSC  0B.7
03B9:  GOTO   3B7
....................   
....................  
....................   	SET_TRIS_A(0b00000010); 
03BA:  MOVLW  02
03BB:  MOVLB  01
03BC:  MOVWF  0C
.................... 	SET_TRIS_B(0b00000000); 
03BD:  MOVLW  00
03BE:  MOVWF  0D
.................... 	SET_TRIS_C(0b10000000); 
03BF:  MOVLW  80
03C0:  MOVWF  0E
.................... 	SET_TRIS_E(0b00001000); 
03C1:  BSF    10.3
....................  
....................      
....................     port_c_pullups(0b11000000); 
03C2:  MOVLW  C0
03C3:  MOVLB  04
03C4:  MOVWF  0E
03C5:  MOVLB  01
03C6:  BCF    15.7
....................      
....................     rs485_init(); 
03C7:  MOVLB  00
03C8:  GOTO   0DC
....................  
....................     enable_interrupts(GLOBAL); 
03C9:  MOVLW  C0
03CA:  IORWF  0B,F
....................      
....................  //   data=0b10000111; 
....................      
....................    int ahmet[]={99}; 
03CB:  MOVLW  63
03CC:  MOVWF  51
....................    int  veli,old_veli; 
....................    unsigned int8 reflected_msg[3]; 
....................      
.................... 	while(1) 
.................... 		{ 
....................             restart_wdt(); 
03CD:  CLRWDT
....................  
.................... 			if	(TIME_MAKER>=2)		//1msn lik i?ler 
03CE:  MOVF   28,W
03CF:  SUBLW  01
03D0:  BTFSC  03.0
03D1:  GOTO   3D5
.................... 			{ 
....................                 restart_wdt(); 
03D2:  CLRWDT
.................... 				TIME_MAKER=0; 
03D3:  CLRF   28
.................... 				++REG_10ms; 
03D4:  INCF   29,F
.................... 				/////// 
....................                  
....................  
....................                  
....................    
.................... 			}	 
....................  
.................... 			if	(REG_10ms>=10)		//10msn lik i?ler 
03D5:  MOVF   29,W
03D6:  SUBLW  09
03D7:  BTFSC  03.0
03D8:  GOTO   3FA
.................... 			{ 
.................... 				REG_10ms=0; 
03D9:  CLRF   29
.................... 				++REG_50ms; 
03DA:  INCF   2A,F
.................... 				/////// 
....................                  
....................                 veli=rs485_buffer[6]; 
03DB:  MOVF   45,W
03DC:  MOVWF  52
....................                 reflected_msg[0] = rs485_buffer[4]; 
03DD:  MOVF   43,W
03DE:  MOVWF  54
....................                 reflected_msg[1] = rs485_buffer[5]; 
03DF:  MOVF   44,W
03E0:  MOVWF  55
....................                 reflected_msg[2] = rs485_buffer[6]; 
03E1:  MOVF   45,W
03E2:  MOVWF  56
....................                 AssignDigits(veli); 
03E3:  CLRF   58
03E4:  MOVF   52,W
03E5:  MOVWF  57
03E6:  GOTO   156
....................                     rs485_ni=0; 
03E7:  CLRF   3D
....................                  
....................                 if(veli!=old_veli) 
03E8:  MOVF   53,W
03E9:  SUBWF  52,W
03EA:  BTFSC  03.2
03EB:  GOTO   3F8
....................                 { 
.................... //                     
.................... //                    memset(&rs485_buffer, 0, sizeof(rs485_buffer)); 
.................... //                    AssignDigits(veli); 
.................... //                    rs485_ni=0; 
....................                     delay_ms(5); 
03EC:  MOVLW  05
03ED:  MOVWF  60
03EE:  CALL   1B0
....................                     rs485_send_message(RS485_DEST_ID,sizeof(reflected_msg),&reflected_msg); 
03EF:  MOVLW  17
03F0:  MOVWF  57
03F1:  MOVLW  03
03F2:  MOVWF  58
03F3:  MOVLW  20
03F4:  MOVWF  5A
03F5:  MOVLW  34
03F6:  MOVWF  59
03F7:  GOTO   206
....................                 } 
....................                 old_veli=veli;  
03F8:  MOVF   52,W
03F9:  MOVWF  53
....................  
.................... 			}	 
....................  
.................... 			if	(REG_50ms>=5)		//50msn lik i?ler 
03FA:  MOVF   2A,W
03FB:  SUBLW  04
03FC:  BTFSC  03.0
03FD:  GOTO   400
.................... 			{ 
.................... 				REG_50ms=0; 
03FE:  CLRF   2A
.................... 				++REG_100ms; 
03FF:  INCF   2B,F
.................... 				/////// 
.................... //                 output_toggle(LED); 
....................  
....................      		}	 
.................... 			 
.................... 			if	(REG_100ms>=2)		//100msn lik i?ler 
0400:  MOVF   2B,W
0401:  SUBLW  01
0402:  BTFSC  03.0
0403:  GOTO   406
.................... 			{ 
.................... 				REG_100ms=0; 
0404:  CLRF   2B
.................... 				++REG_500ms; 
0405:  INCF   2C,F
.................... 				/////// 
.................... //                to*=12; 
....................                  
....................  
....................                  
....................  
.................... 			}		 
.................... 		  
.................... 			if	(REG_500ms>=5)		//500msn lik i?ler 
0406:  MOVF   2C,W
0407:  SUBLW  04
0408:  BTFSC  03.0
0409:  GOTO   40C
.................... 			{ 
.................... 				REG_500ms=0; 
040A:  CLRF   2C
.................... 				++REG_1s; 
040B:  INCF   2D,F
.................... 				/////// 
....................  
.................... 			}	 
.................... 		 	 
.................... 		 	if	(REG_1s>=2)		//1000msn lik i?ler 
040C:  MOVF   2D,W
040D:  SUBLW  01
040E:  BTFSS  03.0
.................... 			{ 
.................... 				REG_1s=0; 
040F:  CLRF   2D
.................... 				/////// 
.................... //                data=0b10000111; 
.................... //                ++data; 
.................... //                data=0x38; 
.................... //                rs485_wait_for_bus(TRUE); 
.................... //                rs485_send_message(RS485_DEST_ID,1,&ahmet,); 
.................... //                AssignDigits(ahmet[0]); 
....................  
....................             } 
....................          
....................             if	(REG_10s>=10)		//10 saniye lik isler 
0410:  MOVF   2E,W
0411:  SUBLW  09
0412:  BTFSS  03.0
.................... 			{ 
....................                 REG_10s=0; 
0413:  CLRF   2E
.................... 				/////// 
....................     
....................             } 
0414:  GOTO   3CD
....................              
.................... 		} 
.................... 		 
.................... } 
....................  
0415:  SLEEP
....................  

Configuration Fuses:
   Word  1: 0E44   INTRC_IO NOWDT PUT MCLR PROTECT CPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NOLPBOR NODEBUG NOLVP
